        -:    0:Source:D:/Code/Clion/software_engineering/lab1_git/DirectedGraph.cpp
        -:    0:Graph:D:\Code\Clion\software_engineering\lab1_git\cmake-build-debug\CMakeFiles\BlackTest.dir\test\test_black.cpp.gcno
        -:    0:Data:D:\Code\Clion\software_engineering\lab1_git\cmake-build-debug\CMakeFiles\BlackTest.dir\test\test_black.cpp.gcda
        -:    0:Runs:1
        -:    1:#include <algorithm>
        -:    2:#include <cstdlib>
        -:    3:#include <fstream>
        -:    4:#include <iostream>
        -:    5:#include <limits>
        -:    6:#include <map>
        -:    7:#include <queue>
        -:    8:#include <random>
        -:    9:#include <set>
        -:   10:#include <sstream>
        -:   11:#include <stack>
        -:   12:#include <string>
        -:   13:#include <vector>
        -:   14:using namespace std;
        -:   15:
        -:   16:// 有向图类定义
        -:   17:class DirectedGraph {
        -:   18:private:
        -:   19:  // 邻接表表示的有向图
        -:   20:  // 所有节点集合
        -:   21:  map<string, double> pageRank; // PageRank值存储
        -:   22:
        -:   23:  // 预处理文本：转换为小写，移除标点符号和非字母字符
        -:   24:  string preprocessText(const string &text) {
        -:   25:    string result;
        -:   26:    for (char c : text) {
        -:   27:      if (isalpha(c)) {
        -:   28:        result += tolower(c);
        -:   29:      } else if (isspace(c) || c == '\n' || c == '\r') {
        -:   30:        result += ' ';
        -:   31:      }
        -:   32:      // 忽略其他所有字符
        -:   33:    }
        -:   34:    return result;
        -:   35:  }
        -:   36:
        -:   37:  // 分割文本为单词列表
        -:   38:  vector<string> splitWords(const string &text) {
        -:   39:    vector<string> words;
        -:   40:    stringstream ss(text);
        -:   41:    string word;
        -:   42:    while (ss >> word) {
        -:   43:      words.push_back(word);
        -:   44:    }
        -:   45:    return words;
        -:   46:  }
        -:   47:
        -:   48:  // 生成DOT格式的图描述
        -:   49:  string generateDotFormat() const {
        -:   50:    stringstream dot;
        -:   51:    dot << "digraph G {\n";
        -:   52:    dot << "  rankdir=LR;\n";
        -:   53:    dot << "  node [shape=circle];\n";
        -:   54:
        -:   55:    // 添加所有节点
        -:   56:    for (const auto &node : nodes) {
        -:   57:      dot << "  \"" << node << "\";\n";
        -:   58:    }
        -:   59:
        -:   60:    // 添加所有边
        -:   61:    for (const auto &from : adjacencyList) {
        -:   62:      for (const auto &to : from.second) {
        -:   63:        dot << "  \"" << from.first << "\" -> \"" << to.first << "\" [label=\""
        -:   64:            << to.second << "\"];\n";
        -:   65:      }
        -:   66:    }
        -:   67:
        -:   68:    dot << "}\n";
        -:   69:    return dot.str();
        -:   70:  }
        -:   71:
        -:   72:protected:
        -:   73:  map<string, map<string, int>> adjacencyList;
        -:   74:
        -:   75:public:
        -:   76:  // 从文本构建有向图
        -:   77:  void buildGraphFromText(const string &filename) {
        -:   78:    ifstream file(filename);
        -:   79:    if (!file.is_open()) {
        -:   80:      cerr << "Error: Could not open file " << filename << endl;
        -:   81:      return;
        -:   82:    }
        -:   83:
        -:   84:    string line;
        -:   85:    string fullText;
        -:   86:    while (getline(file, line)) {
        -:   87:      fullText += preprocessText(line) + " ";
        -:   88:    }
        -:   89:    file.close();
        -:   90:
        -:   91:    vector<string> words = splitWords(fullText);
        -:   92:    if (words.empty()) {
        -:   93:      cerr << "Error: No valid words found in the file." << endl;
        -:   94:      return;
        -:   95:    }
        -:   96:
        -:   97:    // 构建邻接表
        -:   98:    for (size_t i = 0; i < words.size() - 1; i++) {
        -:   99:      string from = words[i];
        -:  100:      string to = words[i + 1];
        -:  101:      nodes.insert(from);
        -:  102:      nodes.insert(to);
        -:  103:      adjacencyList[from][to]++;
        -:  104:    }
        -:  105:  }
        -:  106:
        -:  107:  // 展示有向图并保存为图形文件
        -:  108:  void showDirectedGraph() {
        -:  109:    cout << "Directed Graph:" << endl;
        -:  110:    cout << "----------------" << endl;
        -:  111:    for (const auto &node : nodes) {
        -:  112:      cout << node << " -> ";
        -:  113:      if (adjacencyList.find(node) != adjacencyList.end()) {
        -:  114:        bool first = true;
        -:  115:        for (const auto &edge : adjacencyList.at(node)) {
        -:  116:          if (!first)
        -:  117:            cout << ", ";
        -:  118:          cout << edge.first << "(" << edge.second << ")";
        -:  119:          first = false;
        -:  120:        }
        -:  121:      }
        -:  122:      cout << endl;
        -:  123:    }
        -:  124:    cout << "----------------" << endl;
        -:  125:
        -:  126:    // 生成并保存 DOT 文件
        -:  127:    std::string dotContent = generateDotFormat();
        -:  128:    std::ofstream dotFile("graph.dot");
        -:  129:    if (dotFile.is_open()) {
        -:  130:      dotFile << dotContent;
        -:  131:      dotFile.close();
        -:  132:      std::cout << "Graph DOT file saved as graph.dot" << std::endl;
        -:  133:
        -:  134:      // 尝试使用Graphviz生成图片，并指定输出路径
        -:  135:      std::string outputPath =
        -:  136:          "D:/Code/Clion/software_engineering/lab1/graph.png";
        -:  137:#ifdef _WIN32
        -:  138:      std::string command = "dot -Tpng graph.dot -o " + outputPath;
        -:  139:      system(command.c_str());
        -:  140:#else
        -:  141:      std::string command =
        -:  142:          "dot -Tpng graph.dot -o " + outputPath + " 2>/dev/null";
        -:  143:      system(command.c_str());
        -:  144:#endif
        -:  145:      std::cout << "Graph image saved as " << outputPath
        -:  146:                << " (if Graphviz is installed)" << std::endl;
        -:  147:    } else {
        -:  148:      std::cerr << "Error: Could not save graph DOT file" << std::endl;
        -:  149:    }
        -:  150:  }
        -:  151:
        -:  152:  // 查询桥接词（改进输出格式）
function _ZN13DirectedGraph16queryBridgeWordsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_ called 0 returned 0% blocks executed 0%
    #####:  153:  string queryBridgeWords(const string &word1, const string &word2) {
    #####:  154:    string w1 = word1;
    %%%%%:  154-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  155:    string w2 = word2;
    %%%%%:  155-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  156:    transform(w1.begin(), w1.end(), w1.begin(), ::tolower);
    %%%%%:  156-block  0
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  157:    transform(w2.begin(), w2.end(), w2.begin(), ::tolower);
    %%%%%:  157-block  0
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -:  158:
        -:  159:    // 检查单词是否存在
    #####:  160:    if (nodes.find(w1) == nodes.end() && nodes.find(w2) == nodes.end()) {
    %%%%%:  160-block  0
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  160-block  1
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:  160-block  2
call    7 never executed
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    %%%%%:  160-block  3
call   11 never executed
branch 12 never executed (fallthrough)
branch 13 never executed
    %%%%%:  160-block  4
    %%%%%:  160-block  5
    %%%%%:  160-block  6
branch 14 never executed (fallthrough)
branch 15 never executed
    $$$$$:  160-block  7
    $$$$$:  160-block  8
    $$$$$:  160-block  9
    $$$$$:  160-block 10
    #####:  161:      return "No \"" + word1 + "\" or \"" + word2 + "\" in the graph!";
    %%%%%:  161-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  161-block  1
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:  161-block  2
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%:  161-block  3
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:  161-block  4
    %%%%%:  161-block  5
call   12 never executed
call   13 never executed
call   14 never executed
    $$$$$:  161-block  6
call   15 never executed
    $$$$$:  161-block  7
call   16 never executed
    $$$$$:  161-block  8
call   17 never executed
    $$$$$:  161-block  9
    $$$$$:  161-block 10
    $$$$$:  161-block 11
    #####:  162:    } else if (nodes.find(w1) == nodes.end()) {
    %%%%%:  162-block  0
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  162-block  1
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$:  162-block  2
    $$$$$:  162-block  3
    #####:  163:      return "No \"" + word1 + "\" in the graph!";
    %%%%%:  163-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  163-block  1
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:  163-block  2
    %%%%%:  163-block  3
call    6 never executed
    $$$$$:  163-block  4
call    7 never executed
    $$$$$:  163-block  5
    #####:  164:    } else if (nodes.find(w2) == nodes.end()) {
    %%%%%:  164-block  0
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  164-block  1
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$:  164-block  2
    $$$$$:  164-block  3
    #####:  165:      return "No \"" + word2 + "\" in the graph!";
    %%%%%:  165-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  165-block  1
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:  165-block  2
    %%%%%:  165-block  3
call    6 never executed
    $$$$$:  165-block  4
call    7 never executed
    $$$$$:  165-block  5
        -:  166:    }
        -:  167:
    #####:  168:    set<string> bridgeWords;
    %%%%%:  168-block  0
call    0 never executed
        -:  169:    // 获取word1的所有出边节点
    #####:  170:    if (adjacencyList.find(w1) != adjacencyList.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  170-block  0
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$:  170-block  1
    $$$$$:  170-block  2
    #####:  171:      for (const auto &edge : adjacencyList.at(w1)) {
    %%%%%:  171-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  171-block  1
call    3 never executed
call    4 never executed
    %%%%%:  171-block  2
call    5 never executed
call    6 never executed
    %%%%%:  171-block  3
call    7 never executed
branch  8 never executed
branch  9 never executed (fallthrough)
    #####:  172:        string potentialBridge = edge.first;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  173:        // 检查potentialBridge是否有到word2的边
    #####:  174:        if (adjacencyList.find(potentialBridge) != adjacencyList.end() &&
    %%%%%:  174-block  0
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:  174-block  1
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    %%%%%:  174-block  2
    %%%%%:  174-block  3
    $$$$$:  174-block  4
    $$$$$:  174-block  5
    #####:  175:            adjacencyList.at(potentialBridge).find(w2) !=
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  175-block  0
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
branch  6 never executed (fallthrough)
branch  7 never executed
    $$$$$:  175-block  1
    #####:  176:                adjacencyList.at(potentialBridge).end()) {
    %%%%%:  176-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  176-block  1
call    3 never executed
    %%%%%:  176-block  2
call    4 never executed
    %%%%%:  176-block  3
branch  5 never executed (fallthrough)
branch  6 never executed
    $$$$$:  176-block  4
    #####:  177:          bridgeWords.insert(potentialBridge);
    %%%%%:  177-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  177-block  1
    $$$$$:  177-block  2
        -:  178:        }
    #####:  179:      }
    %%%%%:  179-block  0
call    0 never executed
    $$$$$:  179-block  1
call    1 never executed
        -:  180:    }
        -:  181:
    #####:  182:    if (bridgeWords.empty()) {
    %%%%%:  182-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:  183:      return "No bridge words from \"" + word1 + "\" to \"" + word2 + "\"!";
    %%%%%:  183-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  183-block  1
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:  183-block  2
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%:  183-block  3
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:  183-block  4
    %%%%%:  183-block  5
call   12 never executed
call   13 never executed
call   14 never executed
    $$$$$:  183-block  6
call   15 never executed
    $$$$$:  183-block  7
call   16 never executed
    $$$$$:  183-block  8
call   17 never executed
    $$$$$:  183-block  9
    $$$$$:  183-block 10
    $$$$$:  183-block 11
        -:  184:    }
        -:  185:
        -:  186:    string result =
    #####:  187:        "The bridge words from \"" + word1 + "\" to \"" + word2 + "\" ";
    %%%%%:  187-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  187-block  1
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:  187-block  2
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%:  187-block  3
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
    %%%%%:  187-block  4
call   12 never executed
call   13 never executed
call   14 never executed
    $$$$$:  187-block  5
call   15 never executed
    $$$$$:  187-block  6
call   16 never executed
    $$$$$:  187-block  7
call   17 never executed
    $$$$$:  187-block  8
    $$$$$:  187-block  9
    $$$$$:  187-block 10
    #####:  188:    if (bridgeWords.size() == 1) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:  189:      result += "is: \"" + *bridgeWords.begin() + "\"";
    %%%%%:  189-block  0
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    %%%%%:  189-block  1
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
    %%%%%:  189-block  2
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    %%%%%:  189-block  3
call   11 never executed
call   12 never executed
    $$$$$:  189-block  4
call   13 never executed
    $$$$$:  189-block  5
call   14 never executed
    $$$$$:  189-block  6
    $$$$$:  189-block  7
    $$$$$:  189-block  8
        -:  190:    } else {
    #####:  191:      result += "are: ";
    %%%%%:  191-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  192:      size_t count = 0;
    #####:  193:      for (const string &word : bridgeWords) {
    %%%%%:  193-block  0
call    0 never executed
call    1 never executed
    %%%%%:  193-block  1
call    2 never executed
    %%%%%:  193-block  2
call    3 never executed
branch  4 never executed
branch  5 never executed (fallthrough)
    #####:  194:        if (count > 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  195:          if (count == bridgeWords.size() - 1) {
    %%%%%:  195-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:  196:            result += " and ";
    %%%%%:  196-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  197:          } else {
    #####:  198:            result += ", ";
    %%%%%:  198-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  199:          }
        -:  200:        }
    #####:  201:        result += "\"" + word + "\"";
    %%%%%:  201-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    %%%%%:  201-block  1
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    %%%%%:  201-block  2
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    %%%%%:  201-block  3
call    9 never executed
call   10 never executed
    $$$$$:  201-block  4
call   11 never executed
    $$$$$:  201-block  5
call   12 never executed
    $$$$$:  201-block  6
    $$$$$:  201-block  7
    #####:  202:        count++;
call    0 never executed
        -:  203:      }
        -:  204:    }
    #####:  205:    result += ".";
    %%%%%:  205-block  0
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  206:
    #####:  207:    return result;
    %%%%%:  207-block  0
call    0 never executed
    #####:  208:  }
call    0 never executed
    %%%%%:  208-block  0
call    1 never executed
    %%%%%:  208-block  1
call    2 never executed
call    3 never executed
    $$$$$:  208-block  2
call    4 never executed
    $$$$$:  208-block  3
call    5 never executed
    $$$$$:  208-block  4
call    6 never executed
    $$$$$:  208-block  5
call    7 never executed
        -:  209:
        -:  210:  // 根据桥接词生成新文本
        -:  211:  string generateNewText(const string &inputText) {
        -:  212:    string processedText = preprocessText(inputText);
        -:  213:    vector<string> words = splitWords(processedText);
        -:  214:    if (words.size() < 2) {
        -:  215:      return inputText; // 不足两个单词，无法插入桥接词
        -:  216:    }
        -:  217:
        -:  218:    string result;
        -:  219:    random_device rd;
        -:  220:    mt19937 gen(rd());
        -:  221:
        -:  222:    for (size_t i = 0; i < words.size() - 1; i++) {
        -:  223:      result += words[i] + " ";
        -:  224:
        -:  225:      string w1 = words[i];
        -:  226:      string w2 = words[i + 1];
        -:  227:
        -:  228:      // 检查单词是否存在
        -:  229:      if (nodes.find(w1) == nodes.end() || nodes.find(w2) == nodes.end()) {
        -:  230:        continue;
        -:  231:      }
        -:  232:
        -:  233:      set<string> bridgeWords;
        -:  234:      // 获取桥接词
        -:  235:      if (adjacencyList.find(w1) != adjacencyList.end()) {
        -:  236:        for (const auto &edge : adjacencyList.at(w1)) {
        -:  237:          string potentialBridge = edge.first;
        -:  238:          if (adjacencyList.find(potentialBridge) != adjacencyList.end() &&
        -:  239:              adjacencyList.at(potentialBridge).find(w2) !=
        -:  240:                  adjacencyList.at(potentialBridge).end()) {
        -:  241:            bridgeWords.insert(potentialBridge);
        -:  242:          }
        -:  243:        }
        -:  244:      }
        -:  245:
        -:  246:      if (!bridgeWords.empty()) {
        -:  247:        // 随机选择一个桥接词
        -:  248:        uniform_int_distribution<> dis(0, bridgeWords.size() - 1);
        -:  249:        int index = dis(gen);
        -:  250:        auto it = bridgeWords.begin();
        -:  251:        advance(it, index);
        -:  252:        result += *it + " ";
        -:  253:      }
        -:  254:    }
        -:  255:    result += words.back(); // 添加最后一个单词
        -:  256:
        -:  257:    return result;
        -:  258:  }
        -:  259:
        -:  260:  // 计算两个单词之间的最短路径（增加单单词功能）
        -:  261:  string calcShortestPath(const string &word1, const string &word2 = "") {
        -:  262:    string w1 = word1;
        -:  263:    string w2 = word2;
        -:  264:    transform(w1.begin(), w1.end(), w1.begin(), ::tolower);
        -:  265:    transform(w2.begin(), w2.end(), w2.begin(), ::tolower);
        -:  266:
        -:  267:    // 检查单词是否存在
        -:  268:    if (nodes.find(w1) == nodes.end()) {
        -:  269:      return "No \"" + word1 + "\" in the graph!";
        -:  270:    }
        -:  271:
        -:  272:    // 单单词模式：计算到所有其他节点的最短路径
        -:  273:    if (w2.empty()) {
        -:  274:      string result = "Shortest paths from \"" + word1 + "\":\n";
        -:  275:
        -:  276:      // Dijkstra算法实现（单源最短路径）
        -:  277:      map<string, int> distances;
        -:  278:      map<string, string> previous;
        -:  279:      priority_queue<pair<int, string>, vector<pair<int, string>>,
        -:  280:                     greater<pair<int, string>>>
        -:  281:          pq;
        -:  282:
        -:  283:      // 初始化距离
        -:  284:      for (const string &node : nodes) {
        -:  285:        distances[node] = numeric_limits<int>::max();
        -:  286:      }
        -:  287:      distances[w1] = 0;
        -:  288:      pq.push({0, w1});
        -:  289:
        -:  290:      while (!pq.empty()) {
        -:  291:        string current = pq.top().second;
        -:  292:        pq.pop();
        -:  293:
        -:  294:        if (adjacencyList.find(current) == adjacencyList.end()) {
        -:  295:          continue; // 当前节点没有出边
        -:  296:        }
        -:  297:
        -:  298:        for (const auto &edge : adjacencyList.at(current)) {
        -:  299:          string neighbor = edge.first;
        -:  300:          int weight = edge.second;
        -:  301:          int newDist = distances[current] + weight;
        -:  302:
        -:  303:          if (newDist < distances[neighbor]) {
        -:  304:            distances[neighbor] = newDist;
        -:  305:            previous[neighbor] = current;
        -:  306:            pq.push({newDist, neighbor});
        -:  307:          }
        -:  308:        }
        -:  309:      }
        -:  310:
        -:  311:      // 输出所有可达路径
        -:  312:      for (const string &node : nodes) {
        -:  313:        if (node == w1)
        -:  314:          continue;
        -:  315:
        -:  316:        if (distances[node] == numeric_limits<int>::max()) {
        -:  317:          result += "  No path to \"" + node + "\"\n";
        -:  318:          continue;
        -:  319:        }
        -:  320:
        -:  321:        // 构建路径字符串
        -:  322:        stack<string> path;
        -:  323:        string current = node;
        -:  324:        while (current != w1) {
        -:  325:          path.push(current);
        -:  326:          current = previous[current];
        -:  327:        }
        -:  328:        path.push(w1);
        -:  329:
        -:  330:        result += "  To \"" + node + "\": ";
        -:  331:        while (!path.empty()) {
        -:  332:          result += path.top();
        -:  333:          path.pop();
        -:  334:          if (!path.empty()) {
        -:  335:            result += " -> ";
        -:  336:          }
        -:  337:        }
        -:  338:        result += " (Length: " + to_string(distances[node]) + ")\n";
        -:  339:      }
        -:  340:
        -:  341:      return result;
        -:  342:    }
        -:  343:
        -:  344:    // 双单词模式：原功能
        -:  345:    if (nodes.find(w2) == nodes.end()) {
        -:  346:      return "No \"" + word2 + "\" in the graph!";
        -:  347:    }
        -:  348:
        -:  349:    // Dijkstra算法实现
        -:  350:    map<string, int> distances;
        -:  351:    map<string, string> previous;
        -:  352:    priority_queue<pair<int, string>, vector<pair<int, string>>,
        -:  353:                   greater<pair<int, string>>>
        -:  354:        pq;
        -:  355:
        -:  356:    // 初始化距离
        -:  357:    for (const string &node : nodes) {
        -:  358:      distances[node] = numeric_limits<int>::max();
        -:  359:    }
        -:  360:    distances[w1] = 0;
        -:  361:    pq.push({0, w1});
        -:  362:
        -:  363:    while (!pq.empty()) {
        -:  364:      string current = pq.top().second;
        -:  365:      pq.pop();
        -:  366:
        -:  367:      if (current == w2) {
        -:  368:        break; // 找到目标节点
        -:  369:      }
        -:  370:
        -:  371:      if (adjacencyList.find(current) == adjacencyList.end()) {
        -:  372:        continue; // 当前节点没有出边
        -:  373:      }
        -:  374:
        -:  375:      for (const auto &edge : adjacencyList.at(current)) {
        -:  376:        string neighbor = edge.first;
        -:  377:        int weight = edge.second;
        -:  378:        int newDist = distances[current] + weight;
        -:  379:
        -:  380:        if (newDist < distances[neighbor]) {
        -:  381:          distances[neighbor] = newDist;
        -:  382:          previous[neighbor] = current;
        -:  383:          pq.push({newDist, neighbor});
        -:  384:        }
        -:  385:      }
        -:  386:    }
        -:  387:
        -:  388:    if (distances[w2] == numeric_limits<int>::max()) {
        -:  389:      return "No path from \"" + word1 + "\" to \"" + word2 + "\"!";
        -:  390:    }
        -:  391:
        -:  392:    // 构建路径字符串
        -:  393:    stack<string> path;
        -:  394:    string current = w2;
        -:  395:    while (current != w1) {
        -:  396:      path.push(current);
        -:  397:      current = previous[current];
        -:  398:    }
        -:  399:    path.push(w1);
        -:  400:
        -:  401:    string result;
        -:  402:    while (!path.empty()) {
        -:  403:      result += path.top();
        -:  404:      path.pop();
        -:  405:      if (!path.empty()) {
        -:  406:        result += " -> ";
        -:  407:      }
        -:  408:    }
        -:  409:    result += " (Length: " + to_string(distances[w2]) + ")";
        -:  410:
        -:  411:    return result;
        -:  412:  }
        -:  413:
        -:  414:  // 计算PageRank
        -:  415:  double calcPageRank(const string &word, double d = 0.85,
        -:  416:                      int iterations = 100) {
        -:  417:    string w = word;
        -:  418:    transform(w.begin(), w.end(), w.begin(), ::tolower);
        -:  419:
        -:  420:    if (nodes.find(w) == nodes.end()) {
        -:  421:      return -1.0; // 单词不存在
        -:  422:    }
        -:  423:
        -:  424:    // 初始化PageRank值
        -:  425:    double initialRank = 1.0 / nodes.size();
        -:  426:    for (const string &node : nodes) {
        -:  427:      pageRank[node] = initialRank;
        -:  428:    }
        -:  429:
        -:  430:    // 迭代计算PageRank
        -:  431:    for (int i = 0; i < iterations; i++) {
        -:  432:      map<string, double> newRank;
        -:  433:
        -:  434:      // 计算每个节点的新PR值
        -:  435:      for (const string &node : nodes) {
        -:  436:        double sum = 0.0;
        -:  437:
        -:  438:        // 找出所有指向node的节点
        -:  439:        for (const string &inNode : nodes) {
        -:  440:          if (adjacencyList.find(inNode) != adjacencyList.end() &&
        -:  441:              adjacencyList[inNode].find(node) != adjacencyList[inNode].end()) {
        -:  442:            // 计算贡献值: PR(inNode) / L(inNode)
        -:  443:            sum += pageRank[inNode] / adjacencyList[inNode].size();
        -:  444:          }
        -:  445:        }
        -:  446:
        -:  447:        newRank[node] = (1.0 - d) / nodes.size() + d * sum;
        -:  448:      }
        -:  449:
        -:  450:      // 更新PageRank值
        -:  451:      for (const auto &entry : newRank) {
        -:  452:        pageRank[entry.first] = entry.second;
        -:  453:      }
        -:  454:    }
        -:  455:
        -:  456:    return pageRank[w];
        -:  457:  }
        -:  458:
        -:  459:  // 随机游走（改进文件保存）
        -:  460:  string randomWalk() {
        -:  461:    if (nodes.empty()) {
        -:  462:      return "Graph is empty!";
        -:  463:    }
        -:  464:
        -:  465:    // 随机选择一个起始节点
        -:  466:    random_device rd;
        -:  467:    mt19937 gen(rd());
        -:  468:    uniform_int_distribution<> dis(0, nodes.size() - 1);
        -:  469:    auto it = nodes.begin();
        -:  470:    advance(it, dis(gen));
        -:  471:    string current = *it;
        -:  472:
        -:  473:    set<pair<string, string>> visitedEdges;
        -:  474:    string result;
        -:  475:    result += current;
        -:  476:
        -:  477:    while (true) {
        -:  478:      // 检查当前节点是否有出边
        -:  479:      if (adjacencyList.find(current) == adjacencyList.end() ||
        -:  480:          adjacencyList[current].empty()) {
        -:  481:        break;
        -:  482:      }
        -:  483:
        -:  484:      // 随机选择一个出边
        -:  485:      vector<pair<string, int>> edges(adjacencyList[current].begin(),
        -:  486:                                      adjacencyList[current].end());
        -:  487:      uniform_int_distribution<> edgeDis(0, edges.size() - 1);
        -:  488:      int edgeIndex = edgeDis(gen);
        -:  489:      string next = edges[edgeIndex].first;
        -:  490:
        -:  491:      // 检查是否已经访问过这条边
        -:  492:      if (visitedEdges.find({current, next}) != visitedEdges.end()) {
        -:  493:        break;
        -:  494:      }
        -:  495:
        -:  496:      visitedEdges.insert({current, next});
        -:  497:      current = next;
        -:  498:      result += " " + current;
        -:  499:    }
        -:  500:
        -:  501:    // 将结果写入文件
        -:  502:    ofstream outFile(
        -:  503:        "D:\\Code\\Clion\\software_engineering\\lab1\\random_walk.txt");
        -:  504:    if (outFile.is_open()) {
        -:  505:      outFile << result;
        -:  506:      outFile.close();
        -:  507:      cout << "Random walk result saved to "
        -:  508:              "D:\\Code\\Clion\\software_engineering\\lab1\\random_walk.txt"
        -:  509:           << endl;
        -:  510:    } else {
        -:  511:      cerr << "Error: Could not save random walk result" << endl;
        -:  512:    }
        -:  513:
        -:  514:    return result;
        -:  515:  }
        -:  516:  set<string> nodes;
        -:  517:};
